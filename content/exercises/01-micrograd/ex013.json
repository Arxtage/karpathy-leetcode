{
  "id": "01-micrograd-ex013",
  "lectureId": "01-micrograd",
  "segmentId": "01-micrograd-seg10",
  "title": "Implement Full backward() Method",
  "difficulty": "medium",
  "order": 13,
  "topics": ["backpropagation", "autograd"],
  "description": "Add a `backward()` method to Value that:\n1. Sets `self.grad = 1.0`\n2. Builds topological order of the graph\n3. Calls `_backward()` on each node in reverse topological order\n\nThis automates backpropagation through the entire computation graph.",
  "starterCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._children = set(_children)\n        self._op = _op\n        self._backward = lambda: None\n\n    def __repr__(self):\n        return f\"Value(data={self.data}, grad={self.grad})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n\n        out._backward = _backward\n        return out\n\n    def backward(self):\n        # TODO: implement backward\n        # 1. Set self.grad = 1.0\n        # 2. Build topological order using DFS\n        # 3. Reverse it and call _backward() on each node\n        pass",
  "solutionCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._children = set(_children)\n        self._op = _op\n        self._backward = lambda: None\n\n    def __repr__(self):\n        return f\"Value(data={self.data}, grad={self.grad})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n\n        out._backward = _backward\n        return out\n\n    def backward(self):\n        topo = []\n        visited = set()\n\n        def build(v):\n            if v not in visited:\n                visited.add(v)\n                for child in v._children:\n                    build(child)\n                topo.append(v)\n\n        build(self)\n        self.grad = 1.0\n        for node in reversed(topo):\n            node._backward()",
  "testCode": "try:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    d = Value(4.0)\n    e = c + d\n    e.backward()\n    assert e.grad == 1.0\n    print(\"PASS: e.grad is 1.0\")\nexcept:\n    print(\"FAIL: e.grad is 1.0\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    d = Value(4.0)\n    e = c + d\n    e.backward()\n    assert c.grad == 1.0\n    print(\"PASS: c.grad is 1.0\")\nexcept:\n    print(\"FAIL: c.grad is 1.0\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    d = Value(4.0)\n    e = c + d\n    e.backward()\n    assert d.grad == 1.0\n    print(\"PASS: d.grad is 1.0\")\nexcept:\n    print(\"FAIL: d.grad is 1.0\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    d = Value(4.0)\n    e = c + d\n    e.backward()\n    assert a.grad == 3.0\n    print(\"PASS: a.grad is 3.0 (de/da = b.data)\")\nexcept:\n    print(\"FAIL: a.grad is 3.0 (de/da = b.data)\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    d = Value(4.0)\n    e = c + d\n    e.backward()\n    assert b.grad == 2.0\n    print(\"PASS: b.grad is 2.0 (de/db = a.data)\")\nexcept:\n    print(\"FAIL: b.grad is 2.0 (de/db = a.data)\")",
  "hints": [
    "Set self.grad = 1.0 first (the gradient of the output w.r.t. itself)",
    "Build topological order, reverse it, then call _backward on each node",
    "Reuse the topological sort logic from the previous exercise"
  ]
}
