{
  "id": "01-micrograd-ex013",
  "lectureId": "01-micrograd",
  "segmentId": "01-micrograd-seg11",
  "title": "Implement Full backward() Method",
  "difficulty": "medium",
  "order": 13,
  "topics": [
    "backpropagation",
    "autograd"
  ],
  "description": "Add a `backward()` method to `Value` that automatically computes gradients for the entire computation graph.\n\nStarting from the output node (whose gradient with respect to itself is 1.0), propagate gradients through every node in the correct order using topological sort and each node's `_backward` function.",
  "starterCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._children = set(_children)\n        self._op = _op\n        self._backward = lambda: None\n\n    def __repr__(self):\n        return f\"Value(data={self.data}, grad={self.grad})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n\n        out._backward = _backward\n        return out\n\n    def backward(self):\n        # TODO: implement backward\n        # 1. Set self.grad = 1.0\n        # 2. Build topological order using DFS\n        # 3. Reverse it and call _backward() on each node\n        pass",
  "solutionCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._children = set(_children)\n        self._op = _op\n        self._backward = lambda: None\n\n    def __repr__(self):\n        return f\"Value(data={self.data}, grad={self.grad})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n\n        out._backward = _backward\n        return out\n\n    def backward(self):\n        topo = []\n        visited = set()\n\n        def build(v):\n            if v not in visited:\n                visited.add(v)\n                for child in v._children:\n                    build(child)\n                topo.append(v)\n\n        build(self)\n        self.grad = 1.0\n        for node in reversed(topo):\n            node._backward()",
  "testCode": "try:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    d = Value(4.0)\n    e = c + d\n    e.backward()\n    assert e.grad == 1.0\n    print(\"PASS: e.grad is 1.0\")\nexcept Exception as e:\n    print(f\"FAIL: e.grad is 1.0 — {e}\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    d = Value(4.0)\n    e = c + d\n    e.backward()\n    assert c.grad == 1.0\n    print(\"PASS: c.grad is 1.0\")\nexcept Exception as e:\n    print(f\"FAIL: c.grad is 1.0 — {e}\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    d = Value(4.0)\n    e = c + d\n    e.backward()\n    assert d.grad == 1.0\n    print(\"PASS: d.grad is 1.0\")\nexcept Exception as e:\n    print(f\"FAIL: d.grad is 1.0 — {e}\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    d = Value(4.0)\n    e = c + d\n    e.backward()\n    assert a.grad == 3.0\n    print(\"PASS: a.grad is 3.0 (de/da = b.data)\")\nexcept Exception as e:\n    print(f\"FAIL: a.grad is 3.0 (de/da = b.data) — {e}\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    d = Value(4.0)\n    e = c + d\n    e.backward()\n    assert b.grad == 2.0\n    print(\"PASS: b.grad is 2.0 (de/db = a.data)\")\nexcept Exception as e:\n    print(f\"FAIL: b.grad is 2.0 (de/db = a.data) — {e}\")",
  "hints": [
    "Set self.grad = 1.0 first (the gradient of the output w.r.t. itself)",
    "Build topological order, reverse it, then call _backward on each node",
    "Reuse the topological sort logic from the previous exercise"
  ]
}
