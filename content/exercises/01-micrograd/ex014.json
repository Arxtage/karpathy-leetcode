{
  "id": "01-micrograd-ex014",
  "lectureId": "01-micrograd",
  "segmentId": "01-micrograd-seg12",
  "title": "Implement __pow__ for Value",
  "difficulty": "easy",
  "order": 14,
  "topics": [
    "value-class",
    "operator-overloading"
  ],
  "description": "Add `__pow__` to `Value` so that `Value(x) ** n` works, where `n` is a plain number (int/float). Include the correct backward pass.\n\nRecall the power rule from calculus for the derivative of x^n.",
  "starterCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._children = set(_children)\n        self._op = _op\n        self._backward = lambda: None\n\n    def __repr__(self):\n        return f\"Value(data={self.data}, grad={self.grad})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n\n        out._backward = _backward\n        return out\n\n    def __pow__(self, other):\n        assert isinstance(other, (int, float)), \"only int/float powers supported\"\n        # TODO: implement forward and backward for power\n        # Forward: self.data ** other\n        # Backward: other * (self.data ** (other - 1)) * out.grad\n        pass\n\n    def backward(self):\n        topo = []\n        visited = set()\n\n        def build(v):\n            if v not in visited:\n                visited.add(v)\n                for child in v._children:\n                    build(child)\n                topo.append(v)\n\n        build(self)\n        self.grad = 1.0\n        for node in reversed(topo):\n            node._backward()",
  "solutionCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._children = set(_children)\n        self._op = _op\n        self._backward = lambda: None\n\n    def __repr__(self):\n        return f\"Value(data={self.data}, grad={self.grad})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n\n        out._backward = _backward\n        return out\n\n    def __pow__(self, other):\n        assert isinstance(other, (int, float)), \"only int/float powers supported\"\n        out = Value(self.data ** other, (self,), f'**{other}')\n\n        def _backward():\n            self.grad += other * (self.data ** (other - 1)) * out.grad\n\n        out._backward = _backward\n        return out\n\n    def backward(self):\n        topo = []\n        visited = set()\n\n        def build(v):\n            if v not in visited:\n                visited.add(v)\n                for child in v._children:\n                    build(child)\n                topo.append(v)\n\n        build(self)\n        self.grad = 1.0\n        for node in reversed(topo):\n            node._backward()",
  "testCode": "try:\n    v = Value(3.0)\n    w = v ** 2\n    assert w.data == 9.0\n    print(\"PASS: Value(3) ** 2 has data 9.0\")\nexcept:\n    print(\"FAIL: Value(3) ** 2 has data 9.0\")\n\ntry:\n    v = Value(3.0)\n    w = v ** 2\n    w.backward()\n    assert v.grad == 6.0\n    print(\"PASS: gradient of x**2 at x=3 is 6.0\")\nexcept:\n    print(\"FAIL: gradient of x**2 at x=3 is 6.0\")\n\ntry:\n    v = Value(2.0)\n    w = v ** 3\n    assert w.data == 8.0\n    print(\"PASS: Value(2) ** 3 has data 8.0\")\nexcept:\n    print(\"FAIL: Value(2) ** 3 has data 8.0\")\n\ntry:\n    v = Value(2.0)\n    w = v ** 3\n    w.backward()\n    assert v.grad == 12.0\n    print(\"PASS: gradient of x**3 at x=2 is 12.0\")\nexcept:\n    print(\"FAIL: gradient of x**3 at x=2 is 12.0\")\n\ntry:\n    v = Value(4.0)\n    w = v ** 0.5\n    assert abs(w.data - 2.0) < 1e-6\n    print(\"PASS: Value(4) ** 0.5 has data 2.0\")\nexcept:\n    print(\"FAIL: Value(4) ** 0.5 has data 2.0\")",
  "hints": [
    "n is a plain number, not a Value",
    "Power rule: d/dx(x^n) = n*x^(n-1)",
    "Don't forget to multiply by out.grad (chain rule)"
  ]
}
