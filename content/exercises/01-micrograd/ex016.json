{
  "id": "01-micrograd-ex016",
  "lectureId": "01-micrograd",
  "segmentId": "01-micrograd-seg10",
  "title": "Reverse Operators and Convenience Methods",
  "difficulty": "easy",
  "order": 16,
  "topics": [
    "value-class",
    "operator-overloading"
  ],
  "description": "Add convenience methods so `Value` works naturally in Python expressions:\n\n- `2 + Value(3)` should work (not just `Value(3) + 2`)\n- `2 * Value(3)` should work\n- `-Value(5)` should negate\n- `Value(5) - Value(3)` should subtract\n- `Value(6) / Value(2)` should divide\n\nImplement these in terms of operations you already have.",
  "starterCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._backward = lambda: None\n        self._prev = set(_children)\n        self._op = _op\n\n    def __repr__(self):\n        return f\"Value(data={self.data}, grad={self.grad})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n        out._backward = _backward\n        return out\n\n    def __pow__(self, other):\n        assert isinstance(other, (int, float)), \"only supporting int/float powers for now\"\n        out = Value(self.data ** other, (self,), f'**{other}')\n        def _backward():\n            self.grad += (other * self.data ** (other - 1)) * out.grad\n        out._backward = _backward\n        return out\n\n    def relu(self):\n        out = Value(0 if self.data < 0 else self.data, (self,), 'relu')\n        def _backward():\n            self.grad += (out.data > 0) * out.grad\n        out._backward = _backward\n        return out\n\n    def backward(self):\n        topo = []\n        visited = set()\n        def build_topo(v):\n            if v not in visited:\n                visited.add(v)\n                for child in v._prev:\n                    build_topo(child)\n                topo.append(v)\n        build_topo(self)\n        self.grad = 1.0\n        for v in reversed(topo):\n            v._backward()\n\n    # TODO: Implement __radd__(self, other)\n\n    # TODO: Implement __rmul__(self, other)\n\n    # TODO: Implement __neg__(self)\n\n    # TODO: Implement __sub__(self, other)\n\n    # TODO: Implement __truediv__(self, other)",
  "solutionCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._backward = lambda: None\n        self._prev = set(_children)\n        self._op = _op\n\n    def __repr__(self):\n        return f\"Value(data={self.data}, grad={self.grad})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n        out._backward = _backward\n        return out\n\n    def __pow__(self, other):\n        assert isinstance(other, (int, float)), \"only supporting int/float powers for now\"\n        out = Value(self.data ** other, (self,), f'**{other}')\n        def _backward():\n            self.grad += (other * self.data ** (other - 1)) * out.grad\n        out._backward = _backward\n        return out\n\n    def relu(self):\n        out = Value(0 if self.data < 0 else self.data, (self,), 'relu')\n        def _backward():\n            self.grad += (out.data > 0) * out.grad\n        out._backward = _backward\n        return out\n\n    def backward(self):\n        topo = []\n        visited = set()\n        def build_topo(v):\n            if v not in visited:\n                visited.add(v)\n                for child in v._prev:\n                    build_topo(child)\n                topo.append(v)\n        build_topo(self)\n        self.grad = 1.0\n        for v in reversed(topo):\n            v._backward()\n\n    def __radd__(self, other):\n        return self + other\n\n    def __rmul__(self, other):\n        return self * other\n\n    def __neg__(self):\n        return self * -1\n\n    def __sub__(self, other):\n        return self + (-other)\n\n    def __truediv__(self, other):\n        return self * other**-1",
  "testCode": "try:\n    a = Value(3.0)\n    result = 2 + a\n    assert result.data == 5.0, f\"Expected 5.0, got {result.data}\"\n    print(\"PASS: 2 + Value(3) == 5\")\nexcept:\n    print(\"FAIL: 2 + Value(3) == 5\")\n\ntry:\n    a = Value(3.0)\n    result = 2 * a\n    assert result.data == 6.0, f\"Expected 6.0, got {result.data}\"\n    print(\"PASS: 2 * Value(3) == 6\")\nexcept:\n    print(\"FAIL: 2 * Value(3) == 6\")\n\ntry:\n    a = Value(5.0)\n    result = -a\n    assert result.data == -5.0, f\"Expected -5.0, got {result.data}\"\n    print(\"PASS: -Value(5) == -5\")\nexcept:\n    print(\"FAIL: -Value(5) == -5\")\n\ntry:\n    a = Value(5.0)\n    b = Value(3.0)\n    result = a - b\n    assert result.data == 2.0, f\"Expected 2.0, got {result.data}\"\n    print(\"PASS: Value(5) - Value(3) == 2\")\nexcept:\n    print(\"FAIL: Value(5) - Value(3) == 2\")\n\ntry:\n    a = Value(6.0)\n    b = Value(2.0)\n    result = a / b\n    assert abs(result.data - 3.0) < 1e-6, f\"Expected 3.0, got {result.data}\"\n    print(\"PASS: Value(6) / Value(2) == 3\")\nexcept:\n    print(\"FAIL: Value(6) / Value(2) == 3\")\n\ntry:\n    a = Value(4.0)\n    b = Value(2.0)\n    c = a / b\n    c.backward()\n    assert abs(a.grad - 0.5) < 1e-6, f\"Expected grad 0.5 for a, got {a.grad}\"\n    assert abs(b.grad - (-1.0)) < 1e-6, f\"Expected grad -1.0 for b, got {b.grad}\"\n    print(\"PASS: backward through division\")\nexcept:\n    print(\"FAIL: backward through division\")",
  "hints": [
    "__radd__ is called when Python can't do int + Value, it tries Value.__radd__(int)",
    "Implement them in terms of existing operations"
  ]
}
