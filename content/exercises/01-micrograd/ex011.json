{
  "id": "01-micrograd-ex011",
  "lectureId": "01-micrograd",
  "segmentId": "01-micrograd-seg09",
  "title": "Backward Closure for Multiplication",
  "difficulty": "medium",
  "order": 11,
  "topics": ["backpropagation", "closures"],
  "description": "Modify `__mul__` so that `out._backward` propagates gradients correctly.\n\nFor `c = a * b`, the backward pass should do:\n```\na.grad += b.data * c.grad\nb.grad += a.data * c.grad\n```",
  "starterCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._children = set(_children)\n        self._op = _op\n        self._backward = lambda: None\n\n    def __repr__(self):\n        return f\"Value(data={self.data}, grad={self.grad})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n\n        # TODO: define a _backward closure that propagates gradients\n        # For multiplication c = a * b:\n        #   dc/da = b.data\n        #   dc/db = a.data\n        # Don't forget to multiply by out.grad (chain rule)\n        def _backward():\n            pass  # fix this\n\n        out._backward = _backward\n        return out",
  "solutionCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._children = set(_children)\n        self._op = _op\n        self._backward = lambda: None\n\n    def __repr__(self):\n        return f\"Value(data={self.data}, grad={self.grad})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n\n        out._backward = _backward\n        return out",
  "testCode": "try:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    c.grad = 1.0\n    c._backward()\n    assert a.grad == 3.0\n    print(\"PASS: a.grad is 3.0 (b.data * c.grad)\")\nexcept:\n    print(\"FAIL: a.grad is 3.0 (b.data * c.grad)\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    c.grad = 1.0\n    c._backward()\n    assert b.grad == 2.0\n    print(\"PASS: b.grad is 2.0 (a.data * c.grad)\")\nexcept:\n    print(\"FAIL: b.grad is 2.0 (a.data * c.grad)\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a * b\n    assert c.data == 6.0\n    print(\"PASS: c.data is 6.0\")\nexcept:\n    print(\"FAIL: c.data is 6.0\")\n\ntry:\n    a = Value(4.0)\n    b = Value(5.0)\n    c = a * b\n    c.grad = 2.0\n    c._backward()\n    assert a.grad == 10.0\n    print(\"PASS: a.grad is 10.0 with c.grad=2.0 (chain rule)\")\nexcept:\n    print(\"FAIL: a.grad is 10.0 with c.grad=2.0 (chain rule)\")",
  "hints": [
    "For c=a*b: dc/da = b.data, dc/db = a.data",
    "Multiply the local derivative by out.grad (chain rule)",
    "Use += for gradient accumulation"
  ]
}
