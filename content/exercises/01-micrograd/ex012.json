{
  "id": "01-micrograd-ex012",
  "lectureId": "01-micrograd",
  "segmentId": "01-micrograd-seg11",
  "title": "Topological Sort",
  "difficulty": "medium",
  "order": 12,
  "topics": [
    "graph-algorithms",
    "backpropagation"
  ],
  "description": "Implement `topological_sort(root)` that returns all nodes in the computation graph in an order where every node appears after its children.\n\nThis ordering is needed so we can process gradients in the right sequence during backpropagation — from the output back to the inputs.",
  "starterCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._children = set(_children)\n        self._op = _op\n        self._backward = lambda: None\n\n    def __repr__(self):\n        return f\"Value(data={self.data})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n        return out\n\ndef topological_sort(root):\n    # TODO: return a list of all nodes in topological order\n    # Use DFS with a visited set\n    # Visit children first (post-order), then append the node\n    topo = []\n    visited = set()\n\n    def build(v):\n        pass  # fix this\n\n    build(root)\n    return topo",
  "solutionCode": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0.0\n        self._children = set(_children)\n        self._op = _op\n        self._backward = lambda: None\n\n    def __repr__(self):\n        return f\"Value(data={self.data})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n        return out\n\ndef topological_sort(root):\n    topo = []\n    visited = set()\n\n    def build(v):\n        if v not in visited:\n            visited.add(v)\n            for child in v._children:\n                build(child)\n            topo.append(v)\n\n    build(root)\n    return topo",
  "testCode": "try:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a + b\n    d = Value(4.0)\n    e = c * d\n    topo = topological_sort(e)\n    assert len(topo) == 5\n    print(\"PASS: topological sort has 5 nodes\")\nexcept Exception as e:\n    print(f\"FAIL: topological sort has 5 nodes — {e}\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a + b\n    d = Value(4.0)\n    e = c * d\n    topo = topological_sort(e)\n    assert topo[-1] is e\n    print(\"PASS: root node (e) is last in topological order\")\nexcept Exception as e:\n    print(f\"FAIL: root node (e) is last in topological order — {e}\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a + b\n    d = Value(4.0)\n    e = c * d\n    topo = topological_sort(e)\n    assert topo.index(a) < topo.index(c)\n    assert topo.index(b) < topo.index(c)\n    print(\"PASS: a and b appear before c\")\nexcept Exception as e:\n    print(f\"FAIL: a and b appear before c — {e}\")\n\ntry:\n    a = Value(2.0)\n    b = Value(3.0)\n    c = a + b\n    d = Value(4.0)\n    e = c * d\n    topo = topological_sort(e)\n    assert topo.index(c) < topo.index(e)\n    assert topo.index(d) < topo.index(e)\n    print(\"PASS: c and d appear before e\")\nexcept Exception as e:\n    print(f\"FAIL: c and d appear before e — {e}\")\n\ntry:\n    a = Value(1.0)\n    topo = topological_sort(a)\n    assert len(topo) == 1 and topo[0] is a\n    print(\"PASS: single node returns list of one\")\nexcept Exception as e:\n    print(f\"FAIL: single node returns list of one — {e}\")",
  "hints": [
    "Post-order DFS: visit children first, then append the node",
    "Use a visited set to avoid processing nodes twice",
    "The root node should be last in the returned list"
  ]
}
