{
  "id": "07-gpt-ex002",
  "lectureId": "07-gpt",
  "segmentId": "07-gpt-seg03",
  "title": "Build a Character Tokenizer",
  "difficulty": "easy",
  "order": 2,
  "topics": ["tokenization", "encoding"],
  "runtime": "local",
  "description": "Build a character-level tokenizer by creating two functions:\n\n1. `encode(s)` — takes a string and returns a list of integers, where each character is mapped to its index in the sorted vocabulary.\n2. `decode(l)` — takes a list of integers and returns the original string.\n\nYou will first need to build two lookup dictionaries:\n- `stoi` — a mapping from each character to its integer index\n- `itos` — a mapping from each integer index back to its character\n\nThe vocabulary should be derived from the sorted unique characters of the provided `text` variable.",
  "starterCode": "text = \"First Citizen:\\nBefore we proceed any further, hear me speak.\\n\\nAll:\\nSpeak, speak.\\n\\nFirst Citizen:\\nYou are all resolved rather to die than to famish?\\n\\nAll:\\nResolved. resolved.\\n\\nFirst Citizen:\\nFirst, you know Caius Marcius is chief enemy to the people.\\n\\nAll:\\nWe know't, we know't.\\n\\nFirst Citizen:\\nLet us kill him, and we'll have corn at our own price.\\nIs't a verdict?\\n\\nAll:\\nNo more talking on't; let it be done: away, away!\\n\"\n\nchars = sorted(list(set(text)))\n\n# TODO: build stoi — a dict mapping each character to its integer index\nstoi = None\n\n# TODO: build itos — a dict mapping each integer index to its character\nitos = None\n\ndef encode(s):\n    \"\"\"Take a string, return a list of integers.\"\"\"\n    # TODO: implement\n    pass\n\ndef decode(l):\n    \"\"\"Take a list of integers, return a string.\"\"\"\n    # TODO: implement\n    pass\n",
  "solutionCode": "text = \"First Citizen:\\nBefore we proceed any further, hear me speak.\\n\\nAll:\\nSpeak, speak.\\n\\nFirst Citizen:\\nYou are all resolved rather to die than to famish?\\n\\nAll:\\nResolved. resolved.\\n\\nFirst Citizen:\\nFirst, you know Caius Marcius is chief enemy to the people.\\n\\nAll:\\nWe know't, we know't.\\n\\nFirst Citizen:\\nLet us kill him, and we'll have corn at our own price.\\nIs't a verdict?\\n\\nAll:\\nNo more talking on't; let it be done: away, away!\\n\"\n\nchars = sorted(list(set(text)))\n\nstoi = {ch: i for i, ch in enumerate(chars)}\n\nitos = {i: ch for i, ch in enumerate(chars)}\n\ndef encode(s):\n    \"\"\"Take a string, return a list of integers.\"\"\"\n    return [stoi[c] for c in s]\n\ndef decode(l):\n    \"\"\"Take a list of integers, return a string.\"\"\"\n    return ''.join([itos[i] for i in l])\n",
  "testCode": "try:\n    assert isinstance(stoi, dict), \"stoi should be a dict\"\n    assert isinstance(itos, dict), \"itos should be a dict\"\n    assert len(stoi) == len(chars), f\"stoi should have {len(chars)} entries\"\n    assert len(itos) == len(chars), f\"itos should have {len(chars)} entries\"\n    print(\"PASS: stoi and itos are dicts with correct length\")\nexcept Exception as e:\n    print(f\"FAIL: stoi and itos are dicts with correct length — {e}\")\n\ntry:\n    encoded = encode(\"hello\")\n    assert isinstance(encoded, list), \"encode should return a list\"\n    assert all(isinstance(x, int) for x in encoded), \"encode should return a list of ints\"\n    print(\"PASS: encode returns a list of integers\")\nexcept Exception as e:\n    print(f\"FAIL: encode returns a list of integers — {e}\")\n\ntry:\n    result = decode(encode(\"speak\"))\n    assert result == \"speak\", f\"Expected 'speak', got '{result}'\"\n    print(\"PASS: encode then decode roundtrips correctly for 'speak'\")\nexcept Exception as e:\n    print(f\"FAIL: encode then decode roundtrips correctly for 'speak' — {e}\")\n\ntry:\n    result = decode(encode(\"First Citizen:\\n\"))\n    assert result == \"First Citizen:\\n\", f\"Roundtrip failed for 'First Citizen:\\\\n'\"\n    print(\"PASS: encode/decode roundtrip works for string with newline\")\nexcept Exception as e:\n    print(f\"FAIL: encode/decode roundtrip works for string with newline — {e}\")\n\ntry:\n    e1 = encode(\"a\")\n    e2 = encode(\"b\")\n    assert e1 != e2, \"Different characters should encode to different values\"\n    print(\"PASS: different characters encode to different integers\")\nexcept Exception as e:\n    print(f\"FAIL: different characters encode to different integers — {e}\")\n",
  "hints": [
    "Use a dictionary comprehension: stoi = {ch: i for i, ch in enumerate(chars)} to map each character to its index.",
    "itos is the reverse: {i: ch for i, ch in enumerate(chars)}.",
    "encode uses a list comprehension with stoi; decode joins characters looked up from itos."
  ]
}